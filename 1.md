# Лабораторная работа №1. Знакомство с OpenAI API. Реализация простого текстового ассистента

## Цель работы
Освоить базовые принципы работы с OpenAI API (на примере OpenAI-совместимого HTTP-интерфейса) и разработать консольного текстового ассистента на Python. Ассистент должен поддерживать системный промпт, управление параметром `temperature`, а также хранение истории диалога с ограничением длины контекста.

---

## План работы
1. Подготовка окружения и зависимостей;
2. Реализация обращения к API языковой модели;
3. Реализация основного цикла приложения;
4. Реализация хранения промптов и истории диалога;
5. Выполнение заданий и анализ результатов.

---

## Используемые технологии
- Язык программирования: **Python**
- HTTP-клиент: **requests**
- Переменные окружения: **python-dotenv**
- Хранилище: **SQLite (sqlite3)**

---

## 1. Реализация приложения

Ниже представлен полный исходный код приложения консольного ассистента. Реализованы:
- загрузка ключа и системного промпта из `.env`;
- выполнение запросов к API модели;
- хранение системных промптов в SQLite;
- хранение истории диалога (контекста) в SQLite, ограничение — **6 сообщений** (3 пользователя и 3 ассистента);
- набор команд управления через консоль.

### 1.1 Полный исходный код

```python
import os
import sqlite3
import requests
from dotenv import load_dotenv


load_dotenv()

HF_API_KEY = os.getenv("HF_API_KEY")
SYSTEM_PROMPT = os.getenv(
    "SYSTEM_PROMPT",
    "Ты вежливая и хорошая булочка."
)

BASE_URL = "https://router.huggingface.co/v1/chat/completions"
MODEL_NAME = "openai/gpt-oss-120b"

DB_NAME = "prompts.db"
MAX_MEMORY = 6
temperature = 0.7


def get_db():
    return sqlite3.connect(DB_NAME)


def init_db():
    with get_db() as conn:
        conn.execute("""
            CREATE TABLE IF NOT EXISTS prompts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                content TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

        conn.execute("""
            CREATE TABLE IF NOT EXISTS chat_memory (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)


def save_prompt(name: str, content: str) -> bool:
    try:
        with get_db() as conn:
            conn.execute(
                "INSERT INTO prompts (name, content) VALUES (?, ?)",
                (name, content)
            )
        return True
    except sqlite3.IntegrityError:
        return False


def list_prompts():
    with get_db() as conn:
        return conn.execute(
            "SELECT id, name, content FROM prompts ORDER BY created_at DESC"
        ).fetchall()


def load_prompt(prompt_id: int):
    with get_db() as conn:
        row = conn.execute(
            "SELECT content FROM prompts WHERE id = ?",
            (prompt_id,)
        ).fetchone()
    return row[0] if row else None


def delete_prompt(prompt_id: int):
    with get_db() as conn:
        conn.execute(
            "DELETE FROM prompts WHERE id = ?",
            (prompt_id,)
        )


def save_message(role: str, content: str):
    with get_db() as conn:
        conn.execute(
            "INSERT INTO chat_memory (role, content) VALUES (?, ?)",
            (role, content)
        )

        conn.execute(f"""
            DELETE FROM chat_memory
            WHERE id NOT IN (
                SELECT id FROM chat_memory
                ORDER BY created_at DESC
                LIMIT {MAX_MEMORY}
            )
        """)


def load_memory():
    with get_db() as conn:
        rows = conn.execute("""
            SELECT role, content
            FROM chat_memory
            ORDER BY created_at ASC
        """).fetchall()

    return [{"role": r, "content": c} for r, c in rows]


def clear_memory():
    with get_db() as conn:
        conn.execute("DELETE FROM chat_memory")


def print_history():
    memory = load_memory()
    if not memory:
        print("История пуста.")
        return

    print("\n=== История диалога ===")
    for msg in memory:
        role = "USER" if msg["role"] == "user" else "AI"
        print(f"{role}: {msg['content']}")
    print("======================\n")


def call_llm(messages, temp: float):
    payload = {
        "model": MODEL_NAME,
        "messages": messages,
        "temperature": temp
    }

    headers = {
        "Authorization": f"Bearer {HF_API_KEY}",
        "Content-Type": "application/json"
    }

    r = requests.post(BASE_URL, json=payload, headers=headers)

    if r.status_code != 200:
        return f"Ошибка API: {r.status_code} {r.text}"

    try:
        return r.json()["choices"][0]["message"]["content"]
    except Exception as e:
        return f"Ошибка парсинга ответа: {e}"


def print_help():
    print("""
Команды:
  exit                 — выход (память очищается)
  history              — показать историю диалога
  settemp <0-1>        — изменить temperature
  setprompt            — задать системный промпт
  showprompt           — показать текущий промпт
  saveprompt           — сохранить промпт в БД
  loadprompt           — загрузить промпт из БД
  listprompts          — список всех промптов
  deleteprompt         — удалить промпт
""")


def run_chat():
    global SYSTEM_PROMPT, temperature

    init_db()

    print("=== Консольный AI ассистент ===")
    print(f"Промпт: {SYSTEM_PROMPT}")
    print(f"Temperature: {temperature}")
    print_help()

    while True:
        user_input = input("Вы: ").strip()
        if not user_input:
            continue

        cmd = user_input.lower()

        if cmd == "exit":
            clear_memory()
            print("Память сессии очищена.")
            print("Выход.")
            break

        if cmd == "history":
            print_history()
            continue

        if cmd.startswith("settemp"):
            try:
                value = float(cmd.split()[1])
                if 0 <= value <= 1:
                    temperature = value
                    print(f"temperature = {temperature}")
                else:
                    print("Значение должно быть в диапазоне от 0 до 1")
            except:
                print("Пример: settemp 0.7")
            continue

        if cmd == "setprompt":
            text = input("Новый системный промпт: ").strip()
            if text:
                SYSTEM_PROMPT = text
                print("Промпт обновлён")
            continue

        if cmd == "showprompt":
            print("\nSYSTEM PROMPT:")
            print(SYSTEM_PROMPT)
            continue

        if cmd == "saveprompt":
            name = input("Название промпта: ").strip()
            if save_prompt(name, SYSTEM_PROMPT):
                print("Промпт сохранён")
            else:
                print("Такое имя уже существует")
            continue

        if cmd == "listprompts":
            prompts = list_prompts()
            if not prompts:
                print("Промптов нет")
                continue
            for pid, name, content in prompts:
                print(f"[{pid}] {name} — {content[:60]}")
            continue

        if cmd == "loadprompt":
            pid = int(input("ID промпта: "))
            text = load_prompt(pid)
            if text:
                SYSTEM_PROMPT = text
                print("Промпт загружен")
            else:
                print("Промпт не найден")
            continue

        if cmd == "deleteprompt":
            pid = int(input("ID промпта: "))
            delete_prompt(pid)
            print("Промпт удалён")
            continue

        messages = [{"role": "system", "content": SYSTEM_PROMPT}]
        messages.extend(load_memory())
        messages.append({"role": "user", "content": user_input})

        answer = call_llm(messages, temperature)
        print("AI:", answer)

        save_message("user", user_input)
        save_message("assistant", answer)


if __name__ == "__main__":
    run_chat()





